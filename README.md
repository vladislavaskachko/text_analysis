# text_analysis
## Структура проекта

```
text_analysis/
├── README.md                    # Документация проекта
├── task1/                       # Задание 1: Работа с XML
│   ├── films.xml               # XML-документ с данными о фильмах
│   ├── films.dtd               # DTD схема
│   ├── films.xsd               # XML Schema схема
│   ├── films_schema.json       # JSON Schema схема
│   ├── films_to_txt.xslt       # XSLT преобразование в текстовый формат
│   ├── films_to_html.xslt      # XSLT преобразование в HTML
│   ├── films_to_json.xslt      # XSLT преобразование в JSON
│   ├── output.html             # Результат HTML преобразования
│   ├── output.txt              # Результат TXT преобразования
│   └── Фильмы.ipynb            # Jupyter notebook с программой
└── task2/                       # Задание 2: Анализ вакансий HeadHunter
    └── hh_analysis (1).ipynb    # Jupyter notebook с анализом
└── task3/                       # Задание 3: Обработка документов Word
    ├── документы.ipynb          # Jupyter notebook с программой
    └── ПП_filled.docx           # Заполненный документ (результат)
```

---

## Задание 1: Работа с XML-документами

### 1.1. Разработка XML-формата

Разработан XML-формат для представления каталога фильмов. Документ `films.xml` содержит структурированную информацию о фильмах со следующими элементами:

- **films** — корневой элемент, содержащий коллекцию фильмов
- **film** — элемент фильма с атрибутом `id` (уникальный идентификатор)
- **title** — название фильма
- **genres** — список жанров (может содержать несколько жанров)
- **directors** — список режиссёров
- **composers** — список композиторов
- **cast** — актёрский состав
- **releaseDate** — дата выхода фильма (формат: YYYY-MM-DD)
- **boxOffice** — кассовые сборы с атрибутом `currency` (USD, EUR, RUB, GBP)
- **ageRating** — возрастной рейтинг (0+, 6+, 12+, 16+, 18+)
- **viewerCount** — количество зрителей
- **originalLanguage** — язык оригинала

**Пример структуры:**
```xml
<films>
    <film id="1">
        <title>Персона</title>
        <genres>
            <genre>Драма</genre>
            <genre>Психологический триллер</genre>
        </genres>
        <directors>
            <director>Ингмар Бергман</director>
        </directors>
        ...
    </film>
</films>
```

### 1.2. Разработка XPath-запросов

Реализованы следующие XPath-запросы для работы с XML-документом:

1. **Поиск фильмов по жанру:**
   ```xpath
   //film[genres/genre = 'Драма']
   ```

2. **Фильмы с большим актёрским составом (>5 актёров):**
   ```xpath
   //film[count(cast/actor) > 5]
   ```

3. **Фильмы, где человек является и режиссёром, и актёром:**
   ```xpath
   //film[directors/director = 'Квентин Тарантино' and cast/actor = 'Квентин Тарантино']
   ```

4. **Случайный список просмотра фильмов определённого жанра:**
   ```xpath
   //film[genres/genre = 'Триллер']
   ```

5. **Немецкоязычные драмы с аудиторией > 1 млн:**
   ```xpath
   //film[contains(originalLanguage, 'Немецкий') and viewerCount > 1000000 and genres/genre = 'Драма']
   ```

### 1.3. Описание DTD схемы и валидация

Создана DTD схема (`films.dtd`), которая определяет структуру и правила валидации XML-документа:

```xml
<!ELEMENT films (film+)>
<!ELEMENT film (title, genres, directors, composers, cast, releaseDate, boxOffice, ageRating, viewerCount, originalLanguage)>
<!ATTLIST film id ID #REQUIRED>
...
```

**Особенности DTD схемы:**
- Определены все элементы и их иерархия
- Указаны обязательные атрибуты (`id` для `film`, `currency` для `boxOffice`)
- Заданы правила вложенности элементов

Валидация XML-документа по DTD выполняется программно с использованием библиотеки `lxml` в Python.

### 1.4. Описание XML Schema и валидация

Разработана XML Schema схема (`films.xsd`), которая предоставляет более строгую типизацию по сравнению с DTD:

**Основные возможности:**
- Использование типов данных (`xs:date`, `xs:positiveInteger`, `xs:string`)
- Ограничения на значения атрибутов через `enumeration` (валюта, возрастной рейтинг)
- Определение сложных типов (`filmType`, `genresType`, `castType` и др.)
- Валидация формата даты и числовых значений

**Пример определения типа:**
```xml
<xs:simpleType name="currencyType">
    <xs:restriction base="xs:string">
        <xs:enumeration value="USD"/>
        <xs:enumeration value="EUR"/>
        <xs:enumeration value="RUB"/>
        <xs:enumeration value="GBP"/>
    </xs:restriction>
</xs:simpleType>
```

Валидация XML-документа по XSD также выполняется программно.

### 1.5. XSLT-преобразование в текстовый формат

Создан XSLT-шаблон `films_to_txt.xslt`, который преобразует XML-документ в читаемый текстовый формат.

**Особенности преобразования:**
- Форматированный вывод информации о каждом фильме
- Использование разделителей для улучшения читаемости
- Форматирование чисел (кассовые сборы, количество зрителей)
- Подсчёт общего количества фильмов в каталоге

**Результат:** файл `output.txt` с структурированным текстовым представлением каталога.

### 1.6. XSLT-преобразование в HTML-страницу

Разработан XSLT-шаблон `films_to_html.xslt` для преобразования XML в HTML-страницу с табличным представлением данных.

**Особенности HTML-преобразования:**
- Табличное представление всех фильмов
- Применение CSS-стилей для оформления:
  - Тёмная цветовая схема
  - Градиентные заголовки таблицы
  - Hover-эффекты для строк
  - Цветовые теги для жанров и рейтингов
  - Адаптивное форматирование
- Визуальное выделение важной информации (кассовые сборы, рейтинги)

**Результат:** файл `output.html` — готовая веб-страница с каталогом фильмов.

### 1.7. XSLT-преобразование в JSON

Создан XSLT-шаблон `films_to_json.xslt`, который преобразует XML-структуру в формат JSON.

**Особенности преобразования:**
- Корректное формирование JSON-структуры
- Преобразование атрибутов XML в поля JSON (например, `boxOffice/@currency` → `boxOffice.currency`)
- Массивы для множественных значений (жанры, актёры, режиссёры)
- Вложенные объекты для сложных структур

**Результат:** файл `films.json` с данными в формате JSON.

### 1.8. JSON Schema и валидация

Разработана JSON Schema схема (`films_schema.json`) для валидации полученного JSON-файла.

**Особенности схемы:**
- Определение структуры объекта `films` как массива
- Валидация всех обязательных полей
- Ограничения на типы данных и значения:
  - Минимальные значения для числовых полей
  - Enum для валют и возрастных рейтингов
  - Формат даты
  - Уникальность элементов в массивах
- Использование `$defs` для переиспользования определений

Валидация JSON выполняется с использованием библиотеки `jsonschema` в Python.

### 1.9. Запросы к JSON-файлу

Реализованы запросы к JSON-файлу, эквивалентные XPath-запросам, с использованием библиотеки `jmespath`:

1. **Поиск фильмов по жанру:**
   ```jmespath
   films[?contains(genres, 'Ужасы')]
   ```

2. **Фильмы с большим актёрским составом:**
   ```jmespath
   films[?length(cast) > `5`]
   ```

3. **Фильмы, где человек — режиссёр и актёр:**
   ```jmespath
   films[?contains(directors, 'Квентин Тарантино') && contains(cast, 'Квентин Тарантино')]
   ```

4. **Случайный список просмотра:**
   ```jmespath
   films[?contains(genres, 'Драма')]
   ```

5. **Фильмы 18+ со сборами > 100 млн:**
   ```jmespath
   films[?ageRating == '18+' && boxOffice.amount > `100000000`]
   ```

### 1.10. Программа для выполнения XSLT и запросов

Разработана программа на Python в Jupyter notebook (`Фильмы.ipynb`), которая выполняет все задачи задания 1.

**Функциональность программы:**

1. **Класс `FilmsCatalog`:**
   - Загрузка XML и JSON файлов
   - Валидация XML по DTD и XSD
   - Валидация JSON по JSON Schema
   - Выполнение XSLT-преобразований
   - Выполнение XPath-запросов
   - Выполнение JMESPath-запросов к JSON

2. **Методы валидации:**
   - `validate_dtd()` — валидация по DTD
   - `validate_xsd()` — валидация по XSD
   - `validate_json_schema()` — валидация JSON

3. **Методы преобразования:**
   - `transform()` — выполнение XSLT-преобразований

4. **Методы запросов:**
   - `xpath_by_genre()` — поиск по жанру (XPath)
   - `xpath_large_cast()` — фильмы с большим составом (XPath)
   - `xpath_director_actor()` — режиссёр и актёр (XPath)
   - `xpath_watchlist()` — случайный список (XPath)
   - `xpath_custom()` — пользовательский запрос (XPath)
   - Аналогичные методы для JSON (`json_by_genre()`, `json_large_cast()` и т.д.)

**Используемые библиотеки:**
- `lxml` — работа с XML, XPath, XSLT, валидация
- `jsonschema` — валидация JSON
- `jmespath` — запросы к JSON

---

## Задание 2: Анализ вакансий HeadHunter

### Описание задания

Используя API сайта HeadHunter (https://dev.hh.ru/), реализован анализ вакансий с выполнением следующих задач:

### 2.1. Поиск вакансий и подсчёт средней зарплаты

**Реализованная функциональность:**

1. **Поиск вакансий по тексту:**
   - Метод `search_vacancies()` выполняет поиск вакансий по указанному тексту
   - Поддержка фильтрации по региону (area_id)
   - Пагинация результатов
   - Фильтрация только вакансий с указанной зарплатой

2. **Подсчёт средней зарплаты:**
   - Метод `calculate_average_salary()` вычисляет среднюю зарплату
   - Учитывается валюта вакансии
   - Конвертация всех зарплат в рубли по актуальным курсам
   - Обработка диапазонов зарплат (от-до, только от, только до)

**Поддерживаемые валюты:**
- RUR/RUB (рубли) — курс 1
- USD (доллары) — курс 90
- EUR (евро) — курс 98
- KZT, UAH, BYR, UZS — с соответствующими курсами

**Пример использования:**
```python
analyzer = HHVacancyAnalyzer()
vacancies = analyzer.search_vacancies("Python developer")
avg_salary = analyzer.calculate_average_salary(vacancies)
print(f"Средняя зарплата: {avg_salary:,.0f} ₽")
```

### 2.2. Сравнение зарплат Python-разработчика по городам

Реализован метод `compare_salaries_by_city()`, который сравнивает средние зарплаты Python-разработчика в следующих городах:

- **Москва** (area_id: 1)
- **Санкт-Петербург** (area_id: 2)
- **Екатеринбург** (area_id: 3)
- **Пермь** (area_id: 72)
- **Россия** (area_id: 113) — общий показатель по стране

**Функциональность:**
- Поиск вакансий в каждом городе
- Расчёт средней зарплаты для каждого города
- Вывод результатов в удобном формате
- Рейтинг городов по средней зарплате

**Пример вывода:**
```
СРАВНЕНИЕ ЗАРПЛАТ: Python разработчик

Москва:
   Найдено вакансий: 100
   Средняя з/п: 214,435 ₽

Санкт-Петербург:
   Найдено вакансий: 100
   Средняя з/п: 186,325 ₽

РЕЙТИНГ ПО СРЕДНЕЙ ЗАРПЛАТЕ:
  1. Москва: 214,435 ₽ (100 вакансий)
  2. Санкт-Петербург: 186,325 ₽ (100 вакансий)
  ...
```

### 2.3. Извлечение n-грамм и построение частотного словаря

Реализован анализ навыков и компетенций из описаний вакансий с использованием n-граммного анализа.

**Метод `build_skills_frequency()`:**

1. **Извлечение текста:**
   - Получение полного описания вакансии через API
   - Извлечение ключевых навыков (key_skills)
   - Объединение описания и навыков в единый текст

2. **Обработка текста:**
   - Удаление HTML-тегов и entities
   - Удаление знаков препинания и чисел
   - Приведение к нижнему регистру
   - Токенизация текста

3. **Фильтрация стоп-слов:**
   - Использование библиотеки NLTK для стоп-слов (русский + английский)
   - Дополнительные стоп-слова, специфичные для вакансий
   - Фильтрация коротких слов (менее 3 символов)

4. **Генерация n-грамм:**
   - Извлечение n-грамм (по умолчанию биграмм, n=2)
   - Подсчёт частоты каждой n-граммы

5. **Фильтрация технических терминов:**
   - Выделение n-грамм, содержащих технические ключевые слова
   - Исключение общих фраз с низкой частотой

6. **Построение частотного словаря:**
   - Сортировка по частоте
   - Вывод топ-N наиболее частых n-грамм
   - Визуализация частоты через столбчатую диаграмму

**Пример вывода:**
```
АНАЛИЗ НАВЫКОВ И КОМПЕТЕНЦИЙ: Python разработчик
Загружено вакансий: 150
Используется 375 стоп-слов (NLTK: ru + en)

Топ-25 2-грамм (навыки и компетенции):
--------------------------------------------------
   1. понимание принципов                  20 ██████████
   2. rest api                             20 ██████████
   3. базами данных                        17 ████████
   4. python django                        16 ████████
   5. разработки python                    12 ██████
   ...
```

**Используемые библиотеки:**
- `requests` — работа с HTTP API
- `nltk` — обработка естественного языка, стоп-слова
- `collections.Counter` — подсчёт частоты

---

## Задание 3: Обработка документов Word

### Описание задания

Реализована программа для автоматического заполнения шаблонов документов Word (.docx) на основе данных, введённых пользователем. Программа работает с XML-структурой внутри .docx файлов (так как формат .docx представляет собой ZIP-архив, содержащий XML-файлы).

### 3.1. Работа с форматом .docx

**Особенности формата:**
- Файл .docx является ZIP-архивом, содержащим XML-файлы
- Основной контент документа находится в `word/document.xml`
- Используется пространство имён Office Open XML (OOXML)
- Текст в документе представлен через элементы `w:r` (runs) и `w:t` (text)

### 3.2. Автоматическое заполнение полей

1. **Извлечение документа:**
   - Распаковка .docx файла как ZIP-архива
   - Извлечение XML-структуры документа
   - Парсинг XML с использованием библиотеки `lxml`

2. **Поиск пустых полей:**
   - Метод `is_empty_underlined_run()` определяет пустые подчёркнутые поля
   - Поиск элементов `w:r` с подчёркиванием (`w:u`) и без текста
   - Последовательная обработка всех полей в документе

3. **Заполнение полей:**
   - Метод `replace_next_empty_field()` заменяет содержимое пустых полей
   - Сохранение форматирования (подчёркивание, пробелы)
   - Корректная вставка текста с сохранением XML-структуры

4. **Обработка дат:**
   - Функция `split_date()` разбивает дату формата "ДД.ММ.ГГГГ" на компоненты
   - Автоматическое преобразование года (например, "2025" → "25" для шаблона "Пермь, 20__")
   - Раздельное заполнение дня, месяца и года в разных полях

5. **Сбор данных от пользователя:**
   - Интерактивный ввод данных через `get_user_input()`
   - Сбор следующей информации:
     - ФИО студента
     - Курс и группа
     - Даты начала и окончания практики
     - Наименование предприятия
     - Руководители (от ВШЭ и от предприятия)
     - Год для указания в шаблоне

6. **Сохранение результата:**
   - Запись изменённого XML обратно в архив
   - Создание нового .docx файла с заполненными полями
   - Сохранение всех компонентов документа (стили, метаданные и т.д.)
